# Reference
## Architecture
### Summary
| Directory      | Content
| -------------- | ---------------
| `core`         | The simulator
| `data`         | Automatically generated results, plots, and cached intermediary data
| `lib_ubuntu`   | Dependencies of `run_sundials`, if running on Ubuntu
| `lib_windows`  | Dependencies of `run_sundials`, if running on Windows
| `run_matlab`   | Scripts that run the simulator for different models
| `run_sundials` | Used in running the simulator when the solve mode is set to `CDS_Solver.Solve("sundials")`

### Details
| Directory               | Content
| ----------------------- | ---------------
| `core/includes_matlab`  | Helpers to add `core` to the matlab file path<br> Helpers to obtain filepaths to content in `data`
| `core/CDS`       (CDS)  | The simulator
| `core/Models`    (CDSm) | From the related research article: Models
| `core/Models`    (CDSv) | From the related research article: Values of parameters and inputs
| `core/Utilities` (CDSu) | Helpers to format and plot results
| `data/experiments_results` | From the related research article: Raw data from the trials with a UR5 robot
| `data/matlab_cache`        | Used by some run-files: Cache of simulation results for batch processing
| `data/matlab_fig`          | Used by some run-files: Output path for figures
| `data/sundials_generated`  | Used by some run-files: Cache of generated C++ code
| `data/sundials_results`    | Output path of `run_sundials`, to hold the results
| `run_matlab/Evaluate` | Run-files to evaluate the performance of `core/CDS`
| `run_matlab/Examples` | Sample run-files which depend only on `core/CDS`
| `run_matlab/SimC3`    | From the related research article: Run-files that use `core/Models` and/or `data/experiments_results`
| `run_matlab/Tests`    | Run-files to automatically validate `core/CDS` against known physics
| `run_sundials`             | Bash / Powershell scripts to compile and run the code generated by `CDS_Solver.Solve("sundials")`
| `run_sundials/src/SimC3`    | C++ code which is complied with the code generated by `CDS_Solver.Solve("sundials")`
| `run_sundials/src/test_...` | Tests to validate your correct installation of SUNDIALS and Armadillo C++ libraries

| Class Prefix | Dependencies
| ------------ | ---------------
| CDS          | CDS
| CDSm         | CDS, CDSv
| CDSv, CDSvb  | CDS
| CDSu         | CDS, CDSm, CDSv, CDSvb

Further notes
- `core` is self-contained. It has no external dependencies
- `core` does not directly specify data input/output paths. Paths are chosen by the run-files, or default to the working directory


## Running SUNDIALS
### Prerequisites
Follow the installation instructions for your operating system
- `lib_ubuntu/instructions/Install_Instructions_Ubuntu.txt`
- `lib_windows/instructions/Install_Instructions_Windows.txt`

Location of the generated code
- The generated code must be placed within a subdirectory of `data/sundials_generated`
- This location must be added to the variable `SunGenerated_Includes` in `run_sundials/src/SimC3/CMakeLists.txt`
```CMake
# If the data is at
# 
# data/sundials_generated/MyModel-1/crane_head_shared.cpp
# data/sundials_generated/MyModel-1/crane_head.cpp
# data/sundials_generated/MyModel-1/crane_inputs.cpp
# data/sundials_generated/MyModel-1/crane_ode.cpp
# data/sundials_generated/MyModel-1/crane_x.cpp
# 
# data/sundials_generated/MyOtherModels/Model_2/crane_head_shared.cpp
# data/sundials_generated/MyOtherModels/Model_2/crane_head.cpp
# data/sundials_generated/MyOtherModels/Model_2/crane_inputs.cpp
# data/sundials_generated/MyOtherModels/Model_2/crane_ode.cpp
# data/sundials_generated/MyOtherModels/Model_2/crane_x.cpp
#
# Then the set directive should be
set(SunGenerated_Includes
    "MyModel-1"
    "MyOtherModels/Model_2"
)
```

### Windows (Visual Studio via CLI)
The 3 scripts may be used as follows

`run_sundials/clearBuild.ps1`
```PowerShell
# Delete all files and folders in "run_sundials/build"
./run_sundials/clearBuild.ps1 build

# Non-recursively delete all files in "run_sundials/bin"
./run_sundials/clearBuild.ps1 bin

# Do both of the above
./run_sundials/clearBuild.ps1 all
```

`run_sundials/rebuild.ps1`
```PowerShell
# This script contains a hard coded path to call Visual Studio Community 2022
# If you are running any other version, then you will need to change the path

# Generate the CMake cache and build every executable
./run_sundials/rebuild.ps1
```

`run_sundials/runExe.ps1`
```PowerShell
# Run a specific exe
# ASSUMES
#   The exe is in the directory "run_sundials/bin"
# INPUT
#   exeName: name of the exe
# OUTPUT
#   All output is written to standard out, which should be redirected to a file
./run_sundials/runExe.ps1 -exeName "myExeName.exe" > "../data/sundials_results/myResults/myExeName-output.txt"
```

### Windows (Visual Studio via GUI)
Open the project
1. File > Open > CMake...
2. Choose `run_sundials\src\CMakeLists.txt`

Configure Build settings
- Settings are controlled with `run_sundials\src\CMakeSettings.json`
- Open this file in Visual studio for a GUI to edit it
- Default settings are in `%userprofile%\CMakeBuilds\` (It is safe to delete this folder)

Generate the CMake Cache
- CMake > Cache > Generate
- Or save any `CMakeLists.txt` file

Locate the CMake Cache
- CMake > Cache > Open Cache Folder

Build
- CMake > Build Only > ...

Run
- Use `run_sundials/runExe.ps1`

Run (Alternative)
1. Copy required dll files (e.g. from sundials install) to same directory as the generated exe
2. Use cmd or Powershell to run `myExeName.exe > out.txt`

### Ubuntu
Use the script `run_sundials/ubuntu_buildrun.sh`

The documentation for this script is at the top of the script


## MATLAB Function Reference
### `core/includes_matlab/CDS_GetDataLocations.m`
```MATLAB
%{
PURPOSE
    Get the path to the root project directory or a data directory

% EXAMPLE
    CDS_GetDataLocations().cache()
    # Returns "C:\________\data\matlab_cache"

    CDS_GetDataLocations().cache("aaa","bbb","ccc")
    # Returns "C:\________\data\matlab_cache\aaa\bbb\ccc"
%}
methods
    function this = CDS_GetDataLocations()

    % INPUT
    %   varargin: [string,...] directory hierarchy. Specify one directory per string
    % OUTPUT
    %   Path to the corresponding directory
    function out = root(this,varargin)
    function out = exp_results(this,varargin)
    function out = cache(this,varargin)
    function out = fig(this,varargin)
    function out = sun_generated(this,varargin)
    function out = sun_results(this,varargin)
end
```


### `core/includes_matlab/CDS_IncludeModels.m`
```MATLAB
%{
PURPOSE
    Calling this file includes "core/Models" on the matlab path
%}
```


### `core/includes_matlab/CDS_IncludeSimulator.m`
```MATLAB
%{
PURPOSE
    Calling this file includes "core/CDS" on the matlab path
%}
```


### `core/includes_matlab/CDS_IncludeUtilities.m`
```MATLAB
%{
PURPOSE
    Calling this file includes "core/Utilities" on the matlab path
%}
```


### `core/CDS/CDS_Calc_Energy.m`
```MATLAB
%{
PURPOSE
    Calculate the system energy for any given configuration
    Does not require solving the system

EXAMPLE
    CE = CDS_Calc_Energy(sys);
    CE.InputList
    % Use the displayed list to form the input to CE.V
    energies = CE.V(...);
    energyOfMassB = energies( CE.OutputList.PointIdx("B"), : );
%}
properties (SetAccess=protected)
    % List of all variables in the energy equations (time, generalised coordinates, inputs)
    InputList(:,1) string      % Specifies the column order of inputs to this.V, this.K, this.E
    InputList_0Vel(:,1) string % Specifies the column order of inputs to this.V_0Vel, this.K_0Vel, this.E_0Vel

    % List of all points with mass
    OutputList(:,1) CDS_Point  % Specifies the column order of outputs from all functions

    % Initial conditions
    V0(:,1) double = nan
    K0(:,1) double = nan
    E0(:,1) double = nan
end
methods
    function this = CDS_Calc_Energy(sys)

    % Potential energy
    %   Let
    %       a = length(InputList)
    %       b = number of configurations to calculate the energy of
    %       c = number of masses
    % INPUT
    %   Size
    %       varargin(1,1): (a,b)
    %       varargin(a,1): (1,b), (1,b), (1,b), (1,b), ...
    %   Each column is a set of values corresponding to this.InputList, defining a specific configuration to evaluate
    % OUTPUT
    %   Size: (c,b)
    %   The energy of each mass, keeping the same order as this.OutputList
    function out = V(this, varargin)

    % Kinetic energy
    % INPUT/OUTPUT: same as this.V
    function out = K(this, varargin)

    % Total system energy
    % INPUT
    %   same as this.V
    % OUTPUT
    %   Size: (1,b)
    %   Each element is the total system energy for that configuration
    function out = E(this, varargin)

    % Same as the this.V, this.K, and this.E, but with automatically input 0 time, 0 velocity, 0 acceleration
    % Inputs correspond to this.InputList_0Vel instead of this.InputList
    function out = V_0Vel(this, varargin)
    function out = K_0Vel(this, varargin)
    function out = E_0Vel(this, varargin)
end
```


### `core/CDS/CDS_Helper_StrOut.m`
```MATLAB
%{
PURPOSE
    Various functions to validate, create, and write to text files
%}
properties
    %
end
methods
    function this = CDS_Helper_StrOut()

    %**********************************************************************
    % Interface: Create
    %***********************************
    % Create a folder tree, given a path including the filename
    % INPUT
    %    filePath: path to the file
    function filePath = MakePathToFile(this, filePath)

    %**********************************************************************
    % Interface:
    %   Validate (throws errors)
    %   Check (returns valid/invalid as a boolean)
    %***********************************
    % Validate that a given file path string has the desired file extension
    % The path itself is not validated
    % INPUT
    %   filepath: The path to validate
    %   extension: The file extension that should be at the end of the path
    % OUTPUT
    %   The input path. If there was no extension, then the extension is added
    function filePath = ValidateFileExtension(this, filePath, extension)

    % Check if a given file exists
    % Test the input string without altering it / without any error-correcting
    % INPUT
    %   filepath: The path to validate
    function pathExists = CheckFileExists(this, filePath)

    % Validate that a given file exists
    % INPUT
    %   filepath: The path to validate
    % OUTPUT
    %   The input path. The directory separator is automatically corrected to that of the current OS
    function filePath = ValidateFileExists(this, filePath)

    % Validate a given file path string
    % Its existence is not validated
    % INPUT
    %   filepath: The path to validate
    % OUTPUT
    %   The input path. The directory separator is automatically corrected to that of the current OS
    function filePath = ValidatePath(this, filePath)

    %**********************************************************************
    % Interface: Write
    %***********************************
    % Clear content of txt file
    % INPUT
    %   filePath: path to the file
    function ClearFile(this, filePath)

    % Append string to text file
    % INPUT
    %   str: string to output
    %   filePath: path to the file
    %   mode =
    %       "format": print formatted with 'fprintf()'
    %       "exact": write exact string input with 'fwrite()'
    %       "exactN": write exact string input, then newline
    function StrToTxt(this, str, filePath, mode)

    % Append symbolic expression to text file
    % INPUT
    %   var: symbolic matrix or cell array of symbolic matrices
    %   filePath: path to the file
    %   mode =
    %       "bare": only print the expression (not for cell arrays)
    %       "terminate": bare, but terminate line with ';\n\n'
    %   modeWS =
    %       "normalWS": print spaces within equation
    %       "removeWS": remove spaces from equation
    function SymToTxt(this, var, filePath, mode, modeWS)
end
```


### `core/CDS/CDS_Param.m`
```MATLAB
%{
Abstract Class

PURPOSE
    Instances of this class represent system parameters

COMMON INPUTS
    d: Work with a time derivative of the parameter.
        d=0: (default) the parameter
        d=1: the 1st time derivative of the parameter. Appends 'd' to Sym
        d=2: the 2nd time derivative of the parameter. Appends 'dd' to Sym

NOTES
    matlab.mixin.Heterogeneous
        Allows creation of arrays of params of differing subtypes
        Restrictions (only applies to mixed arrays):
            Can only call methods from common base, and they must be sealed

    Avoid str2sym(), it turns 'i'&'j' into '1i' because imaginary numbers
%}
methods (Sealed=true)
    %**********************************************************************
    % Interface: Set
    %***********************************
    function this = SetSymShort(this, nameIn)
    function this = SetNameReadable(this, nameIn)

    %**********************************************************************
    % Interface: Get
    %***********************************
    % Symbolic variable to represent the parameter
    % INPUT
    %   d: Output as derivative by appending 'd'
    %   t:
    %       t='0': (default) Output as a symbolic variable
    %       t='t': Output as a symbolic function of time
    %   nDiff: For t='t'. Output as derivative by wrapping in diff()
    function symOut = Sym(this, d, t, nDiff)

    % Same as this.Sym, but output as a string
    function strOut = Str(this, d)

    % For code generation. Variable name to represent the parameter in the generated code
    function symOut = SymShort(this, d)

    % Same as this.SymShort, but output as a string
    function strOut = StrShort(this, d)

    % Friendly name to identify the parameter by
    % Used in in outputs, error messages, generated code
    function strOut = NameReadable(this, d)

    % Get specific param objects from an array of param objects
    % INPUT
    %   Same as this.ParamIdx
    function paramObject = Param(this, varargin)

    % Get positions of params in array of param objects
    %   The order of the output corresponds to the order of the input
    %   If a param is not found, then that element is dropped
    % INPUT:
    %   paramsIn
    %       (sym): Array of the values matching the output of CDS_Param.Sym
    %       (string): Array of the values matching the output of CDS_Param.Str
    %       (CDS_Param): Array of CDS_Param
    %   optDuplicates
    %       KeepDuplicates: strictly follow to the input
    %       RemoveDuplicates: Drop duplicate CDS_Param from the output
    %   optWarn
    %       EnableWarn: Warn if for one of the inputs, not matching CDS_Param is found
    %       NoWarn: Disable warnings
    % OUTPUT:
    %   Array of indices to the array calling this method
    function idxMatch = ParamIdx(this, paramsIn, optDuplicates, optWarn)
end
```


### `core/CDS/CDS_Params.m`
```MATLAB
%{
PURPOSE
    Build instances of CDS_Param subclasses
    Track every instance and interface that it creates
%}
properties (SetAccess=private)
    % The parameters created by this instance
    const(:,1) CDS_Param_Const
    q_free(:,1) CDS_Param_Free
    q_input(:,1) CDS_Param_Input
    lambda(:,1) CDS_Param_Lambda
end
methods
    %**********************************************************************
    % Interface: Create
    %***********************************
    function this = CDS_Params()

    % Build instances of CDS_Param subclasses
    % INPUT
    %   paramType
    %       "const":  Build CDS_Param_Const
    %       "free":   Build CDS_Param_Free
    %       "input":  Build CDS_Param_Input
    %       "lambda": Build CDS_Param_Lambda (Intended for internal use only)
    %   paramIn
    %       (string) Symbolic variable to represent the parameter (each parameter must have a unique sym)
    % OUTPUT
    %   The created parameter
    %   The remaining properties are default zero. Change these by calling the set methods on the output
    function paramObject = Create(this, paramType, paramIn)

    %**********************************************************************
    % Interface: Get - Objects
    %***********************************
    % Get the array of all created CDS_Param objects
    function all = All(this)

    % Get the array of all created CDS_Param_Free and CDS_Param_Input objects
    function paramObjectArray = q(this)

    % Get specific param objects
    % INPUT
    %   Same as CDS_Param.ParamIdx
    function paramObject = Param(this, varargin)
end
```


### `core/CDS/CDS_Param_Const.m`
```MATLAB
%{
Creation should be done through CDS_Params.m

PURPOSE
    Instances of this class represent constant system parameters

EXAMPLE
    % Create a parameter with the name "g" and value 9.8
    params = CDS_Params();
    params.Create("const", "g").SetNum(9.8);

    % Get the value of the parameter with the name "g"
    params.Param("g").Num
%}
methods
    %**********************************************************************
    % Interface: Set
    %***********************************
    % Numerical value of the parameter
    function this = SetNum(this, numIn)

    %**********************************************************************
    % Interface: Get
    %***********************************
    % Numerical value of the parameter
    function out = Num(this)
end
```


### `core/CDS/CDS_Param_Free.m`
```MATLAB
%{
Creation should be done through CDS_Params.m

PURPOSE
    Instances of this class represent generalised coordinates / degrees of freedom

EXAMPLE
    % Create a generalised coordinate with the name "theta_1", initial value 0, and initial velocity 0
    % Create a generalised coordinate with the name "theta_2", initial value 2, and initial velocity 0
    % Create a generalised coordinate with the name "theta_3", initial value 3, and initial velocity 30
    params = CDS_Params();
    params.Create("free", "theta_1")
    params.Create("free", "theta_2").SetIC(2);
    params.Create("free", "theta_3").SetIC(3, 30);

    % Get the values of the initial conditions
    params.Param(["theta_1", "theta_2", "theta_3"]).q0
    % Returns [0; 2; 3]
    params.Param(["theta_3", "theta_1", "theta_2"]).q0
    % Returns [3; 0; 2]
    params.Param("theta_3").q0
    % Returns 3
    params.Param("theta_3").q_d0
    % Returns: 30
%}
methods
    %**********************************************************************
    % Interface: Set
    %***********************************
    % Set initial conditions
    % INPUT
    %   q0:     Initial value
    %   q_d0:   Initial velocity
    %   q_dd0:  Initial acceleration
    %   q0_fixed:       (boolean) (default=false) For implicit solvers. Allow solver to change the initial condition?
    %   q_d0_fixed:     (boolean) (default=true)
    %   q_dd0_fixed:    (boolean) (default=true)
    function this = SetIC(this, q0,q_d0,q_dd0, q0_fixed,q_d0_fixed,q_dd0_fixed)

    %**********************************************************************
    % Interface: Get
    %***********************************
    % Initial conditions
    function out = q0(this)
    function out = q_d0(this)
    function out = q_dd0(this)
    function out = q0_fixed(this)
    function out = q_d0_fixed(this)
    function out = q_dd0_fixed(this)
end
```


### `core/CDS/CDS_Param_Input.m`
```MATLAB
%{
Creation should be done through CDS_Params.m

PURPOSE
    Instances of this class represent time and state dependent variable system parameters

EXAMPLE
    % See the HowTo Reference "Define a time dependent parameter (an input)"
%}
properties (SetAccess=private)
    %**********************************************************************
    % Interface: Get
    %***********************************
    % Evaluate input at input time 't' and state 'x'
    % 'x' matches the state vector used by the solver
    % For modes "analytic" and "analyticPiecewise", the value of x is not used. The user might choose to input NaN
    q(1,1) function_handle = @(t,x) 0
    q_d(1,1) function_handle = @(t,x) 0
    q_dd(1,1) function_handle = @(t,x) 0
    
    % Type of input provided by the user
    mode(1,1) string {mustBeMember(mode, ["analytic","analyticFeedback","FeedbackObject","analyticPiecewise","sampled"])} = "analytic"
end
methods
    %**********************************************************************
    % Interface: Set
    %***********************************
    % Common interface for this.SetAnalytic and this.SetPiecewise
    % The appropriate method is automatically determined
    % INPUT
    %   Same as the corresponding method
    %   Optionally pack into a cell array
    function this = Set_Selector(this, varargin)

    % Set the value of the parameter to a analytic function of time
    % INPUT
    %   q_symIn: Symbolic expression of the variable sym('t'), where 't' represents time
    function this = SetAnalytic(this, q_symIn)

    % Set the value of the parameter to an analytic piecewise function of time
    % The first expression will be used until the first transition time, then the next expression will be used, etc.
    % INPUT
    %   q_symIn: Array of symbolic expressions of the variable sym('t'), where 't' represents time
    %   transitionTimes: Array of times to switch between the expressions
    %       length = 1 - length(q_symIn)
    function this = SetPiecewise(this, q_symIn, transitionTimes)

    %**********************************************************************
    % Interface: Get
    %***********************************
    % For analytic modes
    % INPUT
    %   d: differential offset
    % OUTPUT
    %   d=0: Symbolic expression that was input by the user
    %   d=1: 1st time derivative of the symbolic expression that was input by the user
    %   d=2: 2nd time derivative of the symbolic expression that was input by the user
    function symOut = q_Sym(this, d)

    % mode="analyticPiecewise": Times where the piecewise function transitions between expressions
    function out = switchTimes(this)
end
```


### `core/CDS/CDS_Param_Lambda.m`
```MATLAB
%{
Creation is automatic. Should not be manually created
Creation should be done through CDS_Params.m

PURPOSE
    Instances of this class represent Lagrange multipliers
    Used for constrained systems when using a DAE solver
%}
methods
    %**********************************************************************
    % Interface: Set
    %***********************************
    % Set initial conditions
    % Similar to as in CDS_Param_Free.m
    function this = SetIC(this, q0,q_d0, q0_fixed,q_d0_fixed)

    %**********************************************************************
    % Interface: Get
    %***********************************
    % Initial conditions
    function out = q0(this)
    function out = q_d0(this)
    function out = q0_fixed(this)
    function out = q_d0_fixed(this)
end
```


### `core/CDS/CDS_Point.m`
```MATLAB
%{
Creation should be done through CDS_Points.m

PURPOSE
    Instances of this class represent particles, rigid bodies, and massless locations of interest
    The location is defined by a transformation matrix (it has both position and orientation)

NOTATION
    T_AB means the transformation matrix that satisfies the relation P_A = T_AB * P_B, where
        P_A is a point as measured in frame A
        P_B is the same point as measured in frame B
    Frames
        0: The world frame (must be the same for all points in a system)
        n: This point, where
            The origin is at the centre of mass
            The orientation is the orientation of the body (mostly only relevant for rigid bodies)
        p: This point, where
            The origin is the same as for frame n
            The orientation is that about which the moment of inertia was measured
    The transformation T_np is intended to be a constant
%}
properties (SetAccess=private)
    T_0n(1,1) CDS_T = CDS_T(eye(4))
    
    m(1,1) sym = 0 % Default no mass at point
    I_pn(3,3) sym = zeros(3) % Default point mass assumption
    R_np(3,3) sym = eye(3) % Default aligned
end
methods
    %**********************************************************************
    % Interface: Set
    %***********************************
    % Pose of the point in the world frame
    % INPUT
    %   T: CDS_T, where T.T() is a symbolic expression of the parameters registered with CDS_Params
    function this = SetT_0n(this, T)

    % Mass of the point
    % INPUT
    %   m: Symbolic expression of the CDS_Param_Const parameters registered with CDS_Params
    function this = SetMass(this, m)

    % Mass moment of inertia of the point (3x3 matrix)
    % INPUT
    %   I: Symbolic expression of the CDS_Param_Const parameters registered with CDS_Params
    function this = SetInertia(this, I)

    % Orientation at which the moment of inertia was measured, with respect to that of the point (3x3 matrix)
    % INPUT
    %   I: Symbolic expression of the CDS_Param_Const parameters registered with CDS_Params
    function this = SetInertiaR(this, R_np)

    % Friendly name to identify the parameter by
    % Used in in outputs, error messages, generated code
    function this = SetNameShort(this, nameIn)

    %**********************************************************************
    % Interface: Get
    %***********************************
    % Get properties
    function nameOut = NameShort(this)
    function name = NameReadable(this)

    % Test properties of the point
    function logicalOut = HasLinearInertia(this)
    function logicalOut = HasRotationalInertia(this)
    function logicalOut = HasMass(this)
    function logicalOut = IsPointMass(this)
    function logicalOut = IsRigidBody(this)

    % Get specific point objects from an array of point objects
    % INPUT
    %   Same as this.PointIdx
    function pointObject = Point(this, varargin)

    % From an array of point objects, get all the point objects that have mass
    function obj = GetIfHasMass(this)

    % Get positions of params in array of param objects
    %   The order of the output corresponds to the order of the input
    %   If a param is not found, then that element is dropped
    % INPUT:
    %   paramsIn
    %       (string): Array of the values matching the output of CDS_Point.NameShort
    %       (CDS_Point): Array of CDS_Point
    %   optDuplicates
    %       KeepDuplicates: strictly follow to the input
    %       RemoveDuplicates: Drop duplicate CDS_Point from the output
    %   optWarn
    %       EnableWarn: Warn if for one of the inputs, not matching CDS_Point is found
    %       NoWarn: Disable warnings
    % OUTPUT:
    %   Array of indices to the array calling this method
    function idxMatch = PointIdx(this, pointsIn, optDuplicates, optWarn)
end
```


### `core/CDS/CDS_Points.m`
```MATLAB
%{
PURPOSE
    Build instances of CDS_Point
    Track every instance that it creates
    Automatically create and register associated CDS_Param instances for mass and inertia
%}
properties (SetAccess=private)
    % The points created by this instance
    all(:,1) CDS_Point
end
methods
    %**********************************************************************
    % Interface: Create
    %***********************************
    % INPUT
    %   params: CDS_Params
    function this = CDS_Points(params)

    % Build instances of CDS_Point
    % INPUT
    %   sym_append: String to represent the point (each point must have a unique name)
    %   mass_num:
    %       (default=0) Mass of the point.
    %       If non-zero, then a CDS_Param_Const is automatically created with sym="m"+sym_append
    %   inertia_num
    %       (default = 0 matrix) (3x3 matrix) Mass moment of inertia of the point.
    %       If non-zero, then a set of CDS_Param_Const are automatically created with sym="I_xx"+sym_append, etc.
    %       The associated orientation should be configured with CDS_Point.SetInertiaR
    %       An input 3x1 matrix is automatically expanded into a diagonal 3x3 matrix
    % OUTPUT
    %   The created point
    %   The remaining properties are default zero. Change these by calling the set methods on the output
    function pointObject = Create(this, sym_append, mass_num, inertia_num)

    %**********************************************************************
    % Interface: Get
    %***********************************
    % Get specific point objects
    % INPUT
    %   Same as CDS_Point.PointIdx
    function pointObject = Point(this, varargin)
end
```


### `core/CDS/CDS_Solution.m`
```MATLAB
%{
PURPOSE
    Hold post processed solution data

NOTATION
    _d:  1st time derivative
    _dd: 2nd time derivative

NOTES
    Subclasses are used to post-process solution data & fill all the properties of this class
        CDS_SolutionSim
        CDS_SolutionExp
        CDS_SolutionInterpolated
        CDS_SolutionSaved
%}
properties (SetAccess=protected)
    % Solution time
    t(1,:) double
    
    % Generalised coordinates
    q_free(:,1) CDS_Param_Free
    qf(:,:) double    % (q_free,time)
    qf_d(:,:) double  % (q_free,time)
    qf_dd(:,:) double % (q_free,time)
    
    % Time and state dependent variable system parameters
    q_input(:,1) CDS_Param_Input
    qi(:,:) double    % (q_input,time)
    qi_d(:,:) double  % (q_input,time)
    qi_dd(:,:) double % (q_input,time)
    
    % Lagrange multipliers
    q_lambda(:,1) CDS_Param_Lambda
    ql(:,:) double   % (lambda,time)
    ql_d(:,:) double % (lambda,time)
    
    % Points with mass
    p_mass(:,1) CDS_Point
    K(:,:) double % Kinetic energy (K,time)
    V(:,:) double % Potential energy (V,time)
    E(1,:) double % Total system energy (E,time)
    
    % All points
    p_all(:,1) CDS_Point
    Px(:,:) double % Task space position (x,time)
    Py(:,:) double % Task space position (y,time)
    Pz(:,:) double % Task space position (z,time)
    
    % Kinematic chains (for CDS_Solution_Animate)
    chains(1,:) cell % Cell array of linear arrays of CDS_Point instances, where each array is a chain
end
```


### `core/CDS/CDS_SolutionExp.m`
```MATLAB
%{
PURPOSE
    Post-process the results from real-world experimental trials
    Hold the post processed solution data

IMPORTANT NOTE
    The method this.AddPoint_Exp(MyPoint, ...) ignores the value of MyPoint.T_0n
    Because the point is not analytic, T_0n cannot be set
    Hence, the value of MyPoint.T_0n will not be correct and should not be used

NOTES
    Allows mixed coordinates
        Analytic     e.g. Known trajectory of a servo controlled robot
        Experimental e.g. As measured by sensors (I used motion capture)

EXAMPLE
    % Given:
    %   params: CDS_Params
    %   A: (CDS_Point) with all properties appropriately set (T_0A is analytic)
    %   B: (CDS_Point) with all properties appropriately set (T_0B is analytic)
    %   C: (CDS_Point) with all properties except T_0n appropriately set (T_0C was experimentally measured)
    %   D: (CDS_Point) with all properties except T_0n appropriately set (T_0D was experimentally measured)
    %   T_w0: (CDS_T) Transformation between the simulator and experimental world frames
    %   t:    (array of doubles) Sample times of the experimental data
    %   R_wC: (2D array of doubles) Experimentally measured rotations of frame C for each time in t
    %   P_wC: (2D array of doubles) Experimentally measured translations of frame C for each time in t
    %   R_wD: (2D array of doubles) Experimentally measured rotations of frame D for each time in t
    %   P_wD: (2D array of doubles) Experimentally measured translations of frame D for each time in t

    SS = CDS_SolutionExp(params, t);
    SS.AddPoint_Analytic(A);
    SS.AddPoint_Analytic(B);
    SS.AddPoint_Exp(C, T_w0, R_wC, P_wC);
    SS.AddPoint_Exp(D, T_w0, R_wD, P_wD);
    SS.SetChains( {[A,B,C,D]} );
%}
methods
    %**********************************************************************
    % Interface - Create & Initialise
    %***********************************
    % INPUT
    %   params: CDS_Params
    %   t_sol: Sample times of the experimental data
    function this = CDS_SolutionExp(params, t_sol)

    % INPUT
    %   point: CDS_Point with all properties appropriately set
    function AddPoint_Analytic(this, point)

    % NOTATION
    %   T_AB means the transformation matrix that satisfies the relation P_A = T_AB * P_B, where
    %       P_A is a point as measured in frame A
    %       P_B is the same point as measured in frame B
    %   Frames
    %       w: The world frame of the simulator (must be the same for all points in a system)
    %       0: The world frame of the experimental data (e.g. Motion capture world frame)
    %       d: The moving frame in which the data was measured (e.g. Motion capture object frame)
    %       n: This point, where
    %           The origin is at the centre of mass
    %           The orientation is the orientation of the body (mostly only relevant for rigid bodies)
    % INPUT:
    %   point: CDS_Point with all properties except T_0n appropriately set (T_0n is ignored)
    %   T_w0: Static transformation
    %   R_wd: Rotation component of T_wd.    DIM: (time, Rotation matrix in row-major order)
    %   P_wd: Translation component of T_wd. DIM: (time, [x,y,z])
    %   T_dn: Static transformation
    function AddPoint_Exp(this, point, T_w0, R_wd, P_wd, T_dn)

    % Kinematic chains (used only for plotting the animation)
    % INPUT
    %   % Cell array of linear arrays of CDS_Point instances, where each array is a chain
    function SetChains(this, chains)
end
methods (Static)
    %**********************************************************************
    % Interface - Helpers to format input
    %***********************************
    function R_rowMajor = eulerXYZ_to_R_rowMajor(eulerXYZ)
end
```


### `core/CDS/CDS_SolutionInterpolated.m`
```MATLAB
%{
PURPOSE
    Interpolate the whole solution at different time coordinates
    Hold the post processed solution data

EXAMPLE
    % Given:
    %   SS: CDS_Solution that has already been built (for example, an experimental solution)
    %   t:  Times to interpolate the solution at

    SS_new = CDS_SolutionInterpolated(SS, t);
%}
methods
    %**********************************************************************
    % Interface - Create & Initialise
    %***********************************
    % INPUT
    %   SS: CDS_Solution that has already been built
    %   t:  Times to interpolate the solution at
    function this = CDS_SolutionInterpolated(sol, t_new)
end
```


### `core/CDS/CDS_SolutionSaved.m`
```MATLAB
%{
PURPOSE
    Load the previously solved solution that was exported with CDS_Solution_Export
    Hold the post processed solution data

NOTES
    Reimporting the solution requires rebuilding the CDS_SystemDescription object.
    It is your responsibility to ensure that this object is identical to the one that created the exported solution

    Alternatively to this workflow, you may wish to simply export your solution as a .mat file.
    Then you can later import the .mat file

EXAMPLE
    % See the HowTo Reference "Export/Import the post-processed solution"
%}
methods
    %**********************************************************************
    % Interface - Create & Initialise
    %***********************************
    % INPUT
    %   sys: CDS_SystemDescription instance that exactly matches the one that created the exported solution
    %   fileName: path to the file that holds the exported solution
    function this = CDS_SolutionSaved(sys, fileName)
end
```


### `core/CDS/CDS_SolutionSim.m`
```MATLAB
%{
PURPOSE
    Post-process the simulated solution
    Hold the post processed solution data

EXAMPLE
    % Given
    %   sys: CDS_SystemDescription

    S = CDS_Solver;
    [t,x,xd] = S.Solve(sys);
    SS = CDS_SolutionSim(sys, t, x, xd);
%}
methods
    %**********************************************************************
    % Interface - Create & Initialise
    %***********************************
    % INPUT
    %   sys: CDS_SystemDescription that was solved
    %   t_sol,x_sol,xd_sol: Output of CDS_Solver.Solve(sys)
    function this = CDS_SolutionSim(sys, t_sol,x_sol,xd_sol)
end
```


### `core/CDS/CDS_Solution_Animate.m`
```MATLAB
%{
PURPOSE
    Plot the solution as a picture of the configuration in 3D space

NOTES
    The drawn lines join the points in CDS_Solution.chains
    On the drawings, * is used to represent a point with mass
%}
methods
    % INPUT
    %   CDS_Solution
    function this = CDS_Solution_Animate(solution)

    % Select a predefined plot view orientation
    % Intended for y-up coordinate systems
    % INPUT
    %   view_name = "top" | "side" | "front" | "3D-1" | "3D-2"
    function Set_View_Predefined(this, view_name)

    % Draw the system at given moments in time
    %   Uses nearest-neighbour interpolation
    % INPUT
    %   time: Solution times at which to draw the system
    %   aspectRatioMode
    %       "data": (default) Force axis scale ratios 1:1:1
    %       "": Use matlab default axis scale
    %   axes_h: (default = create new figure) handle to axes to plot on
    function PlotFrame(this, frameTimes, aspectRatioMode, axes_h)

    % Animate drawing the system at realtime speed
    % INPUT
    %   mode
    %       "play":  Create a figure and animate
    %       "gif":   Write to gif
    %       "video": Write to mp4
    %   fileName: Filepath to output the gif/video (with the filename, but without the file extension)
    function Animate(this, mode, fileName)
end
```


### `core/CDS/CDS_Solution_Export.m`
```MATLAB
%{
PURPOSE
    Export the solution to an excel file in human readable format

NOTES
    The solution can be reimported with CDS_SolutionSaved
%}
methods
    % INPUT
    %   CDS_Solution
    function this = CDS_Solution_Export(solution)

    % Output solution to excel
    % If file already exists, overwrite entire file
    %    Each sheet holds each variable from CDS_Solution
    % INPUT
    %   fileName: path to the file
    function DataToExcel(this, fileName)
end
```


### `core/CDS/CDS_Solution_GetData.m`
```MATLAB
%{
PURPOSE
    Extract data from CDS_Solution via the names of parameters/points

COMMON INPUTS
Data is retrieved for the input parameters/points
    params
        (string): Array of the values matching the output of CDS_Param.Str
        (CDS_Param): Array of CDS_Param
    points
        (string): Array of the values matching the output of CDS_Point.NameShort
        (CDS_Point): Array of CDS_Point
Data is retrieved for the specified times
    idx_time: (default = all time coordinates) Time coordinates by index, according the time in CDS_Solution.t

NOTES
    The solution array time indices all correspond to the same times
    Therefore the method t_idx() is key to getting data at specified times

EXAMPLE
    % Given: SS = CDS_Solution

    % Get the x coordinates of points ["A", "B"] at the times [2.3, 5.7, 6.5] seconds
    SSg = CDS_Solution_GetData(SS);
    idx = SSg.t_idx([2.3, 5.7, 6.5]);
    position_x = SSg.Px(["A", "B"], idx);

    % Get the time rate of change of theta_1 at the same times
    theta_1_d = SSg.qd("theta_1", idx);
%}
methods
    % INPUT
    %   CDS_Solution
    function this = CDS_Solution_GetData(solution)

    %**********************************************************************
    % Plain data
    %***********************************
    % INPUT
    %   frameTimes: Array of solution times
    % OUTPUT
    %   Indices of the nearest time coordinates to the input times
    function idx_time = t_idx(this, frameTimes)

    % Get the configurations of given parameters at given times
    function out = q(this, params, idx_time)

    % Get the configurations of given parameters at given times
    % First time derivative
    function out = qd(this, params, idx_time)

    % Get the configurations of given parameters at given times
    % Second time derivative
    function out = qdd(this, params, idx_time)

    % Get the position of given points at given times
    % x,y,z coordinates
    function out = Px(this, points, idx_time)
    function out = Py(this, points, idx_time)
    function out = Pz(this, points, idx_time)

    % Get the position of 1 given point at given times
    % Position vector
    function out = P(this, point, idx_time)

    % Get the position of given points at 1 given time
    % Position vector
    function data = xyz(this, idx_time, points)

    %**********************************************************************
    % Formatted data
    %***********************************
    % Same as this.xyz(), but the output is formatted as a table
    function dataTable = xyzTable(this, frameTime, points)

    % Same as this.xyz(), but with the output table transposed
    function dataTable = xyzTable_t(this, varargin)

    %**********************************************************************
    % Operate on data
    %***********************************
    % INPUT
    %   point1:
    %   point2: (default = [0,0,0])
    % OUTPUT
    %   Norm of the task space distance between the 2 points
    function absDistance = AbsDistance(this, point1, point2)

    % ASSUMES
    %   y axis is up
    % INPUT
    %   point1:
    %   point2:
    % OUTPUT
    %   The acute angle between the line joining the 2 points and a vertical line
    function angleFromVertical = AngleFromVertical(this, point1, point2)
end
```


### `core/CDS/CDS_Solution_Plot.m`
```MATLAB
%{
PURPOSE
    Plot the solution as a function of time
%}
methods
    % INPUT
    %   CDS_Solution
    function this = CDS_Solution_Plot(solution)

    % OUTPUT
    %   figure with plot of total system energy vs time
    function PlotEnergyTotal(this)

    % OUTPUT
    %   figure with overlaid plots of each energy component and total system energy vs time
    function PlotEnergyAll(this)

    % INPUT
    %   ax: (default = create new figure) Axes object to plot on
    % OUTPUT
    %   figure with overlaid plots of all state components vs time
    function PlotConfigSpace(this, ax)

    % INPUT
    %   ax: (default = create new figure) Axes object to plot on
    % OUTPUT
    %   figure with overlaid plots of all constraint lambda vs time
    function PlotLambda(this, ax)

    % OUTPUT
    %   figure with overlaid plots of all inputs vs time
    function PlotInput(this)

    % INPUT
    %   dim: axis of coordinates to plot (e.g. "x" = plot x coordinates)
    %   points
    %       (string): Array of the values matching the output of CDS_Point.NameShort
    %       (CDS_Point): Array of CDS_Point
    %   titleString: plot title to display
    % OUTPUT
    %   figure with plot of coordinates in task space
    function PlotTaskSpace(this, dim, points, titleString)

    % OUTPUT
    %   figure with plot of coordinates in task space
    %   variant that plots only the points with mass
    function PlotTaskSpace_Mass(this, dim, titleString)

    % OUTPUT
    %   figure with plot of coordinates in task space
    %   variant that plots all points
    function PlotTaskSpace_All(this, dim, titleString)
end
```


### `core/CDS/CDS_Solver.m`
```MATLAB
%{
PURPOSE
    Generate and solve the equations of motion
%}
methods
    % INPUT
    %   options: (CDS_Solver_Options) Specify additional solver options
    function this = CDS_Solver(options)

    %**********************************************************************
    % Interface - Solve
    %***********************************
    % INPUT
    %   sys:
    %       CDS_SystemDescription
    %   solverName:
    %       auto: ode45
    %       drawIC:   Skips solving, just passes through the ICs. For this mode, the output "xd_sol" is not correct
    %       sundials: (Requires "solveMode"="export") Export ODEs as C++ code for solving with the SUNDIALS CVODE solver
    %       (any standard Matlab solver): Solve with the Matlab solver
    %   solveMode:
    %       auto: Recommended. Choses the best available mode for the input system and chosen solver
    %       fullyImplicit: (Must be used by ode15i)                    Solve   0 = f(t,x,x_d)
    %       massMatrix: (0 constraints / 0 or 1 if solver allows DAEs) Solve   M(t,x) * x_d = f(t,x)
    %       setupTime:  (0 or 1 constraints) Solve   x_d = f(t,x)   where f is formed symbolically before solving
    %       solveTime:  (0 or 1 constraints) Solve   x_d = f(t,x)   where f is formed numerically during solving (via anonymous functions)
    %       solveTime2: (0 or 1 constraints) Solve   x_d = f(t,x)   where f is formed numerically during solving (via CDS_Solver_ODEs_Eval)
    %       export:     (0 or 1 constraints) Export .m or .cpp files to externally solve
    function [t_sol, x_sol, xd_sol] = Solve(this, sys, solverName, solveMode)
end
```


### `core/CDS/CDS_Solver_Options.m`
```MATLAB
%{
PURPOSE
    Pass miscellaneous options to CDS_Solver
%}
properties (Access=public)
    % The time to solve over
    %   If 1x2 array: The start and end times. In-between times are chosen by the solver
    %   If 1xn array: The solution is output at these time coordinates
    time(1,:) double = [0,5]

    % Boolean flag: Pass events function to odeset()?
    EventsIsActive(1,1) logical = 0
    
    % Options passed to odeset()
    RelTol(1,1) double = 10^(-7)
    AbsTol(1,1) double = 10^(-7)
    Stats(1,1) string = 'on'
    Events(1,1) function_handle = @(~,~) "ERROR"

    % Options for exporting
    %   solverName="sundials":         Path to the directory to output the generated files in
    %   (otherwise export for matlab): Path to the file to output, including the filename
    exportPath(1,1) string = ""
end
methods
    function this = CDS_Solver_Options()
end
methods (Access=public)
    % Default events function
    %   Prints the time that the solver is currently up to
    % PURPOSE
    %   If solving is taking a long time, turn this on to check where the solver is stuck at
    %   Really small time increments can indicate that the equations are stiff
    function [value,isTerminal,direction] = myEventsFcn(~, t,~)
end
```


### `core/CDS/CDS_SystemDescription.m`
```MATLAB
%{
PURPOSE
    Hold all of the information required to simulate a system
    An instance of this fully defines a system
%}
properties (SetAccess=private)
    params(1,1) CDS_Params
    points(1,:) CDS_Points % Would force (1,1), but dumb errors
    chains(1,:) cell
    
    g0(3,1) sym = zeros(3,1)
    C(:,1) sym = []
end
methods
    %**********************************************************************
    % Interface: Create
    %***********************************
    % INPUT
    %   params: CDS_Params that holds every param used in points and g0
    %   points: CDS_Points that holds every point to evaluate. Must hold every point that has mass / moment of inertia
    %   chains:
    %       Kinematic chains (used only for plotting the animation)
    %       Cell array of linear arrays of CDS_Point instances, where each array is a chain
    %   g0:
    %       Gravitational acceleration vector
    %       Defines the magnitude of gravity, and the down direction
    function this = CDS_SystemDescription(params, points, chains, g0)

    %**********************************************************************
    % Interface: Set
    %***********************************
    % INPUT
    %   (symbolic expression) Algebraic constraint equation of the form C=0
    function this = SetConstraint(this, C)
end
```


### `core/CDS/CDS_T.m`
```MATLAB
%{
PURPOSE
    Hold a 4x4 homogeneous transformation matrix

NOTES
    Object is immutable
    => Create new instead of editing

EXAMPLE
    % See the HowTo Reference "Use the transformation matrix class CDS_T"
%}
properties (SetAccess=immutable)
    T(4,4)
end
methods
    %**********************************************************************
    % Interface: Create
    %***********************************
    function this = CDS_T(varargin)

    %**********************************************************************
    % Interface: Get
    %***********************************
    % x, y, z
    function out = x(this)
    function out = y(this)
    function out = z(this)

    % R, P, Ph
    function out = R(this)
    function out = P(this)
    function out = Ph(this)

    % Return inverse of T (this object remains unchanged)
    %   Uses mathematical properties of T => cleaner & more efficient than T^-1
    function T_inverted = Inv(this)

    %**********************************************************************
    % Interface: Operator Overloads
    %***********************************
    function c = mtimes(a,b)
end
```
